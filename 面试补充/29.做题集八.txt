1.'%c'%65 ----> 'A' 不等于‘65’

2.chr(ord('b')^32)  ^在二进制下是异或 1^1=0 0^0=0 1^0=1 所以这个会得到66
（注：这个东西也是正则里面的东西）

3.list(str([3,4])) ->['[','3',',','4',']'] 就是这样，str一个list是将整个list都字符化了

4.15//4  ----> 3

5.sorted({'a':3,'b':4,'c':5}) --->['a','b','c'] 默认以字典得key排序，返回一个排序得list，不是dict

6.x=list(range(20))  x[100:200]返回[] 
  x=range(20)  x[100:200]返回 range(20,20) x[1:200] 返回range(1,20)

7.[1,2,3]>[1,3,2] --->false

8.list之间不可以加减，但是set也就是tuple可以，not (set([1,2,3]*100)-set([1,2,3]))-->True

9.x=[1,2,3,4,5] x[::2] = range(3) 这里3只能是3，因为替换的结果是[0,2,1,4,2] 换成2或者4立即报错

10.x=[1,2,3,4,5] x[1::2] = sorted(x[1::2],reverse=True) 这个理解么？因为是reverse为True，所以排序是倒序，然后赋值list都是见缝插空

总结：因为在切片中：[x:y:z] x是规定了值的,这个是起始值,但是y值没有规定,也就是在复制的过程中，这个会见缝插针,z是规定了相差几位开始插,这里注意的是,z的第一个必定是x开始的第一个值，当z为-1的时候，会倒序排列

11.type({}) == dict 为True
   type({}) == set 为False
   type(()) == set 为False

12.x=list(range(20)) x[:18] =[] x-->[18,19]